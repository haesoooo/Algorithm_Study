## Info
<a href="https://www.acmicpc.net/problem/17404" rel="nofollow">17404 RGB거리 2</a>

## 풀이
기존 RGB거리 문제와 다른 점이 있다면 `1번과 N번집의 색은 달라야 한다`는 것이다. 

`dp[i][j]`는 다음과 같이 설정하였다.

* `dp[i][1]` : 1~i-1번집을 칠하는 비용의 최솟값 + i번집에서 빨간색을 선택했을 때 집을 칠하는 비용의 최솟값

* `dp[i][2]` : 1~i-1번집을 칠하는 비용의 최솟값 + i번집에서 초록색을 선택했을 때 집을 칠하는 비용의 최솟값

* `dp[i][3]` : 1~i-1번집을 칠하는 비용의 최솟값 + i번집에서 파란색을 선택했을 때 집을 칠하는 비용의 최솟값

`dp` 배열의 `1행`은 따로 분리하여 설정하였다. `DP` 함수로 1번집의 RGB값이 파라미터로 넘겨져오는데, 이에 해당하지 않는 다른 두 개의 인덱스는 `1000000000`로 설정하여 최솟값에 걸리지 않도록 설정하였다. 처음에는 `INT_MAX`로 설정하였으나 나중에 `dp`배열과 `A`배열을 더하는 과정에서 overflow가 발생하였으므로 2번 더해도 overflow가 발생하지 않게 `1000000000`로 설정한 것이다.

그 다음 `2<=i<=N`에서 `dp[i][1]`, `dp[i][2]`, `dp[i][3]` 값을 할당해주었다. `i(2 ≤ i ≤ N-1)번 집의 색은 i-1, i+1번 집의 색과 같지 않아야 한다`는 조건이 있기 때문에 이에 맞게 동적 프로그래밍을 진행하였다. 예시로 `dp[i][1]`은 `dp[i - 1][2] + A[i][1]`와 `dp[i - 1][3] + A[i][1]` 중 작은 것을 선택한다.

이렇게 for문을 다 돌고 난 뒤 제일 최솟값을 갱신해줘야 하는데, 이 때 `1번집의 RGB값`을 참고하여 진행해야 한다. `1번집`과 `N번집`의 색이 같다면 `minimum`에 갱신할 기회조차 주지 않는다.

## 마무리
결론적으로 풀이를 참고한 문제여서 아쉽다. 2차원 DP, 1차원 DP 가리지 않고 모두 풀어봐야겠다.